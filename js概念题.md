### this指向

`this指的是函数运行时所在的环境，this 永远指向一个对象`

1. 全局性调用函数，函数中的this指向Window
2. 函数作为对象的方法被调用，函数中的this指向这个对象
3. 构造函数中的this指向这个实例化对象
4. call，apply，bind可以改变this指向，this指向的是它要指向的对象，如果没有参数，this指向Window
5. 定时器中的this指向Window
6. 箭头函数中的this指向上下文对象的this，如果没有上下文对象，this指向undefined



### apply，bind，call

`三个方法都是改变this指向，bind 是返回对应函数，不是立即执行，apply 、call 则是立即调用，apply参数是数组，call和bind参数是参数列表`

~~~js
function.apply(thisArg, [argsArray])
~~~

第一个参数是this要指向的对象，第二个参数是数组

```js
function.call(thisArg, arg1, arg2, ...) 
```

第一个参数是this要指向的对象，从第二个参数开始往后，每个参数被依次传入函数

```js
function.bind(thisArg[, arg1[, arg2[, ...]]])
```

第一个参数是this要指向的对象，从第二个参数开始往后，每个参数被依次传入函数



### 原型，原型链

原型：`prototype对象就是实例对象的原型，实例对象继承了构造函数的prototype对象`

原型链：`实例对象都有自己的原型对象，而原型对象也是对象，也有自己的原型对象，这样就形成了一种链式关系，这就是原型链`

p对象----->Person.prototype------->Object.prototype--------->null

1. 构造函数拥有一个属性，这个属性包含一个对象（prototype对象），实例对象会继承构造函数的prototype属性，也就是__`__proto__`__属性
2. prototype对象包含这个构造函数的所有属性和方法
3. 实例对象的`__proto__`属性指向它的构造函数的原型对象（prototype）



### 执行上下文

`执行上下文是当前代码的运行环境`

一段代码被执行时，js引擎先解析，然后创建执行上下文

三种类型：

1. 全局执行上下文（只有一个）

2. 函数执行上下文（无数个）

3. Eval函数执行上下文（不常用）

   全局执行上下文就是所有函数外部的运行环境，编译执行时进栈，当关闭当前页面，全局执行上下文才出栈

   函数执行上下文中的代码，被调用时才会编译执行，进栈，当代码执行完成就出栈

创建步骤：

1. 确定this指向
2. 创建词法环境
3. 创建变量环境

执行时把执行上下文添加进执行上下文栈，后进先出



### 闭包

`当前作用域访问外部作用域变量的函数`

第一，闭包是一个函数，而且存在于另一个函数当中
第二，闭包可以访问到父级函数的变量，且该变量不会销毁

作用1：隐藏变量，避免全局污染

作用2：可以读取函数内部的变量

缺点1：导致变量不会被垃圾回收机制回收，造成内存消耗

缺点2：不恰当的使用闭包可能会造成内存泄漏的问题

闭包的两个场景：

1. 函数作为返回值
2. 函数作为参数传递



### 作用域，作用域链

作用域：`变量，对象，函数的使用范围`

1. 作用域的最大作用就是为了隔离变量，避免命名冲突
2. es5 之前只存在全局作用域和函数作用域，es6的let，const带来了块级作用域

作用域链：当前作用域中没找到要访问的变量时，就会去外层作用域中找，直到找到全局作用域中，这种链式关系就是作用域链



### 浅拷贝，深拷贝

浅拷贝：拷贝的是基本类型的话，拷贝的是值。如果是引用类型，拷贝的是引用地址

浅拷贝方式：

1. = 运算符赋值

2. Object.assign（可以处理一层的深度拷贝）

   ```js
   const newObj = Object.assign({}, obj)
   ```

3. 扩展运算符...（可以处理一层的深度拷贝）

   ```js
    const newObj = {...obj}
   ```

深拷贝：拷贝所有层级的属性，值

深拷贝方式：

1. ```js
   const newObj = JSON.parse(JSON.stringify(obj))
   ```

2. 递归拷贝

3. 第三方包：Lodash



### 同步，异步

js是单线程的，所以是同步的

js通过事件循环实现异步

js 执行机制：从上到下执行，同步任务直接执行，异步任务放入任务队列，直到所有同步任务执行完成，再执行任务队列里面的异步任务

1. 首先判断js代码是同步还是异步,不停的检查调用栈中是否有任务需要执行,如果没有,就检查任务队列,从中弹出一个任务,放入栈中,如此往复循环,要是同步就进入主进程,异步就进入事件表

2. 异步任务在事件表中注册函数,当满足触发条件后,被推入事件队列

3. 同步任务进入主线程后一直执行,直到主线程空闲时,才会去事件队列中查看是否有可执行的异步任务,如果有就推入主进程中



### 宏任务，微任务

js 将任务分为了同步任务和异步任务，异步任务又分为了宏任务和微任务

执行顺序：微任务中的同步任务 —》微任务中的异步任务 —》 宏任务

1. 存在微任务的话，那么就执行所有的微任务
2. 微任务都执行完之后，执行第一个宏任务，
3. 循环 1， 2

宏任务：整体代码script，setTimeout，setInterval

微任务：Promise then catch，process.nextTick



### 事件代理



### 阻止事件冒泡，阻止默认事件



### Cookie和本地存储的区别，优缺点

cookie：

sessionstorage：

localstorage：



### 跨域解决方案有哪些，优缺点

Jsonp

CORS